<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALPAGT</title>
    <link rel="icon" type="image/x-icon" href="images/favicon-32x32.png">
    <style>
        body {
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #000000;
        }
        .centered-text {
            font-size: 4rem;
            font-weight: bold;
            color: #f0f0f0;
            margin-top: 60px;
        }
    </style>
</head>
<body>
    <div class="centered-text">ALPAGT</div>
    <script>
    class ParametricTubeViewer {
        constructor() {
            this.canvas = document.createElement('canvas');
            document.body.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');

            this.state = {
                rotation: { x: 0, y: 0 },
                scale: 1,
                isInteracting: false,
                lastPos: { x: 0, y: 0 }
            };

            this.tube = this.generateTube();
            this.setupEventListeners();
            this.resizeCanvas();
            this.animate();
        }

        generateTube() {
            const params = {
                baseScale: 80,
                radius: 50,
                steps: 1000,
                segments: 80
            };

            return Array.from({ length: params.steps + 1 }, (_, t) => {
                const angle = (2 * Math.PI * t) / params.steps;
                const cx = params.baseScale * (Math.sin(angle) + 2 * Math.sin(2 * angle));
                const cy = params.baseScale * (Math.cos(angle) - 2 * Math.cos(2 * angle));
                const cz = params.baseScale * (-Math.sin(3 * angle));

                const tangent = this.normalizeTangent(angle, params.baseScale);
                const { normal, binormal } = this.computeOrthogonalVectors(tangent);

                return Array.from({ length: params.segments }, (_, i) => {
                    const theta = (2 * Math.PI * i) / params.segments;
                    return {
                        x: cx + params.radius * (Math.cos(theta) * normal.x + Math.sin(theta) * binormal.x),
                        y: cy + params.radius * (Math.cos(theta) * normal.y + Math.sin(theta) * binormal.y),
                        z: cz + params.radius * (Math.cos(theta) * normal.z + Math.sin(theta) * binormal.z)
                    };
                });
            });
        }

        normalizeTangent(angle, baseScale) {
            const tangent = {
                x: baseScale * (Math.cos(angle) + 4 * Math.cos(2 * angle)),
                y: baseScale * (-Math.sin(angle) + 4 * Math.sin(2 * angle)),
                z: baseScale * (-3 * Math.cos(3 * angle))
            };
            const length = Math.hypot(tangent.x, tangent.y, tangent.z);
            return { x: tangent.x / length, y: tangent.y / length, z: tangent.z / length };
        }

        computeOrthogonalVectors(tangent) {
            const up = { x: 0, y: 1, z: 0 };
            const normal = {
                x: up.y * tangent.z - up.z * tangent.y,
                y: up.z * tangent.x - up.x * tangent.z,
                z: up.x * tangent.y - up.y * tangent.x
            };
            const normalLength = Math.hypot(normal.x, normal.y, normal.z);
            normal.x /= normalLength;
            normal.y /= normalLength;
            normal.z /= normalLength;

            const binormal = {
                x: tangent.y * normal.z - tangent.z * normal.y,
                y: tangent.z * normal.x - tangent.x * normal.z,
                z: tangent.x * normal.y - tangent.y * normal.x
            };

            return { normal, binormal };
        }

        setupEventListeners() {
            const handleEvent = (type) => {
                this.canvas.addEventListener(type, (e) => {
                    e.preventDefault();
                    switch(type) {
                        case 'mousedown':
                        case 'touchstart':
                            this.startInteraction(e);
                            break;
                        case 'mousemove':
                        case 'touchmove':
                            this.updateInteraction(e);
                            break;
                        case 'mouseup':
                        case 'touchend':
                        case 'mouseleave':
                        case 'touchcancel':
                            this.endInteraction();
                            break;
                    }
                }, { passive: false });
            };

            ['mousedown', 'mousemove', 'mouseup', 'mouseleave', 
             'touchstart', 'touchmove', 'touchend', 'touchcancel'].forEach(handleEvent);

            window.addEventListener('resize', () => this.resizeCanvas());
            this.canvas.addEventListener('wheel', this.handleZoom.bind(this));
        }

        handleZoom(e) {
            e.preventDefault();
            this.state.scale *= e.deltaY > 0 ? 0.9 : 1.1;
            this.state.scale = Math.max(0.05, Math.min(this.state.scale, 50));
        }

        startInteraction(e) {
            const pos = this.getEventPosition(e);
            this.state.isInteracting = true;
            this.state.lastPos = pos;
        }

        updateInteraction(e) {
            const pos = this.getEventPosition(e);
            if (this.state.isInteracting) {
                this.state.rotation.y += (pos.x - this.state.lastPos.x) * 0.01;
                this.state.rotation.x += (pos.y - this.state.lastPos.y) * 0.01;
                this.state.lastPos = pos;
            }
        }

        getEventPosition(e) {
            const touch = e.touches && e.touches[0];
            return {
                x: touch ? touch.clientX : e.clientX,
                y: touch ? touch.clientY : e.clientY
            };
        }

        endInteraction() {
            this.state.isInteracting = false;
        }

        resizeCanvas() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }

        rotatePoint(point) {
            const { x, y, z } = point;
            const cosY = Math.cos(this.state.rotation.y);
            const sinY = Math.sin(this.state.rotation.y);
            const cosX = Math.cos(this.state.rotation.x);
            const sinX = Math.sin(this.state.rotation.x);

            const rotatedX = cosY * x - sinY * z;
            const rotatedZ = sinY * x + cosY * z;
            const rotatedY = cosX * y - sinX * rotatedZ;
            const finalZ = sinX * y + cosX * rotatedZ;

            return { x: rotatedX, y: rotatedY, z: finalZ };
        }

        project(point) {
            const perspective = 1000;
            const scale = (this.state.scale * perspective) / (point.z + perspective);
            return {
                x: point.x * scale + this.canvas.width / 2,
                y: point.y * scale + this.canvas.height / 2
            };
        }

        animate() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 1;

            for (let i = 0; i < this.tube[0].length; i++) {
                this.ctx.beginPath();
                for (let j = 0; j < this.tube.length; j++) {
                    const point = this.tube[j][i];
                    const rotatedPoint = this.rotatePoint(point);
                    const projectedPoint = this.project(rotatedPoint);
                    j === 0 
                        ? this.ctx.moveTo(projectedPoint.x, projectedPoint.y) 
                        : this.ctx.lineTo(projectedPoint.x, projectedPoint.y);
                }
                this.ctx.stroke();
            }

            requestAnimationFrame(() => this.animate());
        }
    }

    window.addEventListener('load', () => new ParametricTubeViewer());
    </script>
</body>
</html>
