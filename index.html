<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALPAGT</title>
    <link rel="icon" type="image/x-icon" href="images/favicon-32x32.png">
    <style>
        body {
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #000000;
        }
        .centered-text {
            font-size: 4rem;
            font-weight: bold;
            color: #f0f0f0;
            margin-top: 100px;
        }
        canvas {
            touch-action: pinch-zoom; /* Enable pinch-to-zoom */
        }
    </style>
</head>
<body>
    <div class="centered-text">ALPAGT</div>
    <script>
        (function () {
            class ParametricTubeViewer {
                constructor() {
                    this.canvas = document.createElement('canvas');
                    document.body.appendChild(this.canvas);
                    this.ctx = this.canvas.getContext('2d');

                    // Initial parameters
                    this.rotation = { x: 0, y: 0 };
                    this.scale = 1; // Zoom level
                    this.isInteracting = false;
                    this.lastX = 0;
                    this.lastY = 0;

                    // Generate the tube geometry
                    this.tube = this.generateTube();

                    // Resize canvas and set up event listeners
                    this.resizeCanvas();
                    this.setupEventListeners();
                    this.animate();
                }

                generateTube() {
                    const tube = [];
                    const baseScale = 60; // Match original scale
                    const radius = 50;
                    const steps = 1000; // Longitudinal resolution
                    const segments = 80; // Cross-sectional resolution

                    for (let t = 0; t <= steps; t++) {
                        const angle = (2 * Math.PI * t) / steps;
                        const cx = baseScale * (Math.sin(angle) + 2 * Math.sin(2 * angle));
                        const cy = baseScale * (Math.cos(angle) - 2 * Math.cos(2 * angle));
                        const cz = baseScale * (-Math.sin(3 * angle));

                        const tangent = {
                            x: baseScale * (Math.cos(angle) + 4 * Math.cos(2 * angle)),
                            y: baseScale * (-Math.sin(angle) + 4 * Math.sin(2 * angle)),
                            z: baseScale * (-3 * Math.cos(3 * angle))
                        };
                        const tangentLength = Math.sqrt(tangent.x ** 2 + tangent.y ** 2 + tangent.z ** 2);
                        tangent.x /= tangentLength;
                        tangent.y /= tangentLength;
                        tangent.z /= tangentLength;

                        const up = { x: 0, y: 1, z: 0 };
                        const normal = {
                            x: up.y * tangent.z - up.z * tangent.y,
                            y: up.z * tangent.x - up.x * tangent.z,
                            z: up.x * tangent.y - up.y * tangent.x
                        };
                        const normalLength = Math.sqrt(normal.x ** 2 + normal.y ** 2 + normal.z ** 2);
                        normal.x /= normalLength;
                        normal.y /= normalLength;
                        normal.z /= normalLength;

                        const binormal = {
                            x: tangent.y * normal.z - tangent.z * normal.y,
                            y: tangent.z * normal.x - tangent.x * normal.z,
                            z: tangent.x * normal.y - tangent.y * normal.x
                        };

                        const ring = [];
                        for (let i = 0; i < segments; i++) {
                            const theta = (2 * Math.PI * i) / segments;
                            const x = cx + radius * (Math.cos(theta) * normal.x + Math.sin(theta) * binormal.x);
                            const y = cy + radius * (Math.cos(theta) * normal.y + Math.sin(theta) * binormal.y);
                            const z = cz + radius * (Math.cos(theta) * normal.z + Math.sin(theta) * binormal.z);
                            ring.push({ x, y, z });
                        }
                        tube.push(ring);
                    }
                    return tube;
                }

                setupEventListeners() {
                    window.addEventListener('resize', () => this.resizeCanvas());

                    // Mouse interactions
                    this.canvas.addEventListener('mousedown', this.startInteraction.bind(this));
                    this.canvas.addEventListener('mousemove', this.updateInteraction.bind(this));
                    this.canvas.addEventListener('mouseup', this.endInteraction.bind(this));
                    this.canvas.addEventListener('mouseleave', this.endInteraction.bind(this));

                    // Zoom with wheel
                    this.canvas.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        this.scale *= e.deltaY > 0 ? 0.9 : 1.1;
                        this.scale = Math.max(0.05, Math.min(this.scale, 50)); // Limit zoom range
                    });
                }

                resizeCanvas() {
                    this.canvas.width = window.innerWidth*1;
                    this.canvas.height = window.innerHeight*1;
                }

                startInteraction(e) {
                    this.isInteracting = true;
                    this.lastX = e.clientX;
                    this.lastY = e.clientY;
                }

                updateInteraction(e) {
                    if (this.isInteracting) {
                        const dx = e.clientX - this.lastX;
                        const dy = e.clientY - this.lastY;
                        this.rotation.y += dx * 0.01;
                        this.rotation.x += dy * 0.01;
                        this.lastX = e.clientX;
                        this.lastY = e.clientY;
                    }
                }

                endInteraction() {
                    this.isInteracting = false;
                }

                rotatePoint({ x, y, z }) {
                    const cosY = Math.cos(this.rotation.y);
                    const sinY = Math.sin(this.rotation.y);
                    const cosX = Math.cos(this.rotation.x);
                    const sinX = Math.sin(this.rotation.x);

                    const tempX = cosY * x - sinY * z;
                    const tempZ = sinY * x + cosY * z;
                    const tempY = cosX * y - sinX * tempZ;
                    z = sinX * y + cosX * tempZ;

                    return { x: tempX, y: tempY, z };
                }

                project({ x, y, z }) {
                    const perspective = 1000;
                    const scale = (this.scale * perspective) / (z + perspective);
                    return {
                        x: x * scale + this.canvas.width / 2,
                        y: y * scale + this.canvas.height / 2,
                    };
                }

                animate() {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;

                    for (let i = 0; i < this.tube[0].length; i++) {
                        this.ctx.beginPath();
                        for (let j = 0; j < this.tube.length; j++) {
                            const point = this.tube[j][i];
                            const rotatedPoint = this.rotatePoint(point);
                            const projectedPoint = this.project(rotatedPoint);
                            if (j === 0) {
                                this.ctx.moveTo(projectedPoint.x, projectedPoint.y);
                            } else {
                                this.ctx.lineTo(projectedPoint.x, projectedPoint.y);
                            }
                        }
                        this.ctx.stroke();
                    }

                    requestAnimationFrame(() => this.animate());
                }
            }

            window.addEventListener('load', () => new ParametricTubeViewer());
        })();
    </script>
</body>
</html>
