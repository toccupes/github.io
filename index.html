<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALPAGT</title>
    <link rel="icon" type="image/x-icon" href="images/favicon-32x32.png">
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #000000;
        }
        .centered-text {
            font-size: 4rem;
            font-weight: bold;
            color: #f0f0f0;
            margin-top: 60px;
        }
    </style>
</head>
<body>
    <div class="centered-text"><br>ALPAGT</div>
    <script>
        (function () {
            class ParametricTubeViewer {
                constructor() {
                    this.canvas = document.createElement('canvas');
                    document.body.appendChild(this.canvas);
                    this.ctx = this.canvas.getContext('2d');

                    this.rotation = { x: 0, y: 0 };
                    this.scale = 1;
                    this.isInteracting = false;
                    this.lastX = 0;
                    this.lastY = 0;

                    this.touches = [];
                    this.initialDistance = 0;

                    this.tube = this.generateTube();

                    this.resizeCanvas();
                    this.setupEventListeners();
                    this.animate();
                }

                generateTube() {
                    const tube = [];
                    const baseScale = 80;
                    const radius = 50;
                    const steps = 1000;
                    const segments = 80;

                    for (let t = 0; t <= steps; t++) {
                        const angle = (2 * Math.PI * t) / steps;
                        const cx = baseScale * (Math.sin(angle) + 2 * Math.sin(2 * angle));
                        const cy = baseScale * (Math.cos(angle) - 2 * Math.cos(2 * angle));
                        const cz = baseScale * (-Math.sin(3 * angle));

                        const tangent = {
                            x: baseScale * (Math.cos(angle) + 4 * Math.cos(2 * angle)),
                            y: baseScale * (-Math.sin(angle) + 4 * Math.sin(2 * angle)),
                            z: baseScale * (-3 * Math.cos(3 * angle))
                        };
                        const tangentLength = Math.sqrt(tangent.x ** 2 + tangent.y ** 2 + tangent.z ** 2);
                        tangent.x /= tangentLength;
                        tangent.y /= tangentLength;
                        tangent.z /= tangentLength;

                        const up = { x: 0, y: 1, z: 0 };
                        const normal = {
                            x: up.y * tangent.z - up.z * tangent.y,
                            y: up.z * tangent.x - up.x * tangent.z,
                            z: up.x * tangent.y - up.y * tangent.x
                        };
                        const normalLength = Math.sqrt(normal.x ** 2 + normal.y ** 2 + normal.z ** 2);
                        normal.x /= normalLength;
                        normal.y /= normalLength;
                        normal.z /= normalLength;

                        const binormal = {
                            x: tangent.y * normal.z - tangent.z * normal.y,
                            y: tangent.z * normal.x - tangent.x * normal.z,
                            z: tangent.x * normal.y - tangent.y * normal.x
                        };

                        const ring = [];
                        for (let i = 0; i < segments; i++) {
                            const theta = (2 * Math.PI * i) / segments;
                            const x = cx + radius * (Math.cos(theta) * normal.x + Math.sin(theta) * binormal.x);
                            const y = cy + radius * (Math.cos(theta) * normal.y + Math.sin(theta) * binormal.y);
                            const z = cz + radius * (Math.cos(theta) * normal.z + Math.sin(theta) * binormal.z);
                            ring.push({ x, y, z });
                        }
                        tube.push(ring);
                    }
                    return tube;
                }

                setupEventListeners() {
                    window.addEventListener('resize', () => this.resizeCanvas());

                    this.canvas.addEventListener('touchstart', (e) => this.startInteraction(e), { passive: false });
                    this.canvas.addEventListener('touchmove', (e) => this.updateInteraction(e), { passive: false });
                    this.canvas.addEventListener('touchend', () => this.endInteraction());
                    this.canvas.addEventListener('touchcancel', () => this.endInteraction());
                }

                resizeCanvas() {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                }

                startInteraction(e) {
                    e.preventDefault();
                    if (e.touches.length === 2) {
                        this.touches = Array.from(e.touches);
                        this.initialDistance = this.getTouchDistance();
                    } else if (e.touches.length === 1) {
                        this.isInteracting = true;
                        this.lastX = e.touches[0].clientX;
                        this.lastY = e.touches[0].clientY;
                    }
                }

                updateInteraction(e) {
                    e.preventDefault();
                    if (e.touches.length === 2) {
                        const newDistance = this.getTouchDistance(e.touches);
                        this.scale *= newDistance / this.initialDistance;
                        this.scale = Math.max(0.1, Math.min(this.scale, 10));
                        this.initialDistance = newDistance;
                    } else if (this.isInteracting && e.touches.length === 1) {
                        const clientX = e.touches[0].clientX;
                        const clientY = e.touches[0].clientY;
                        this.rotation.y += (clientX - this.lastX) * 0.01;
                        this.rotation.x += (clientY - this.lastY) * 0.01;
                        this.lastX = clientX;
                        this.lastY = clientY;
                    }
                }

                endInteraction() {
                    this.isInteracting = false;
                    this.touches = [];
                }

                getTouchDistance(touches = this.touches) {
                    const [touch1, touch2] = touches;
                    const dx = touch1.clientX - touch2.clientX;
                    const dy = touch1.clientY - touch2.clientY;
                    return Math.sqrt(dx ** 2 + dy ** 2);
                }

                rotatePoint({ x, y, z }) {
                    const cosY = Math.cos(this.rotation.y);
                    const sinY = Math.sin(this.rotation.y);
                    const cosX = Math.cos(this.rotation.x);
                    const sinX = Math.sin(this.rotation.x);

                    const tempX = cosY * x - sinY * z;
                    const tempZ = sinY * x + cosY * z;
                    const tempY = cosX * y - sinX * tempZ;
                    z = sinX * y + cosX * tempZ;

                    return { x: tempX, y: tempY, z };
                }

                project({ x, y, z }) {
                    const perspective = 1000;
                    const scale = (this.scale * perspective) / (z + perspective);
                    return {
                        x: x * scale + this.canvas.width / 2,
                        y: y * scale + this.canvas.height / 2,
                    };
                }

                animate() {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;

                    for (let i = 0; i < this.tube[0].length; i++) {
                        this.ctx.beginPath();
                        for (let j = 0; j < this.tube.length; j++) {
                            const point = this.tube[j][i];
                            const rotatedPoint = this.rotatePoint(point);
                            const projectedPoint = this.project(rotatedPoint);
                            if (j === 0) {
                                this.ctx.moveTo(projectedPoint.x, projectedPoint.y);
                            } else {
                                this.ctx.lineTo(projectedPoint.x, projectedPoint.y);
                            }
                        }
                        this.ctx.stroke();
                    }

                    requestAnimationFrame(() => this.animate());
                }
            }

            window.addEventListener('load', () => new ParametricTubeViewer());
        })();
    </script>
</body>
</html>
